package com.blackhammer.game{		import com.blackhammer.util.*	import flash.display.*;	import flash.geom.*;	import flash.media.*;	import flash.events.*;		import com.greensock.*;	//import com.greensock.easing.*;	//import com.greensock.OverwriteManager;		public class Board extends MovieClip{			private var _startX:Number = 40;		private var _startY:Number = 104;		private var _SShapeStartX:Number;		private var _SShapeStartY:Number;		private var _SShapeW:Number;		private var _SShapeH:Number;		public var _numOfRows:Number = 5;		public var _numOfColumns:Number = 5;		public var _numOfBlanks:Number;		public var _numOfStones:Number;		public var _numOfHoles:Number;		private var _solution:Array = []		private var _solvedTiles:Array = [];		private var _tileW:int = 55; //50;		private var _tileH:int = 55; //50;		private var _daSpace:Number = 0; //extra space between tiles		private var _tileArray:Array = [];		//private var _tileArray:Vector.<Object> = new Vector.<Object>();		//private var _tileLocArray:Array = []; //parallel array for location points		private var _tileLocArray:Vector.<Point> = new Vector.<Point>(); //parallel array for location points		private var _tileMapArray:Vector.<Number> = new Vector.<Number>(); //parallel array for mapping tile states - 1 to 5 for tileNum, -1 for empty, -2 for stone		private var _tileHoleArray:Array = [];		private var _tileHoleMapArray:Vector.<Number> = new Vector.<Number>(); //parallel array for mapping hole states		private var _isHolePresent:Boolean;		private var _holePositionArray:Vector.<Number> = new Vector.<Number>();		private var _myDaddy:Object;				private var _g:Graphics;		private var _gSprite:Sprite = new Sprite();		private var _b:Graphics;		private var _bSprite:Sprite = new Sprite();		private var _board:Sprite = new Sprite();		private var _solutionsShape:Sprite = new Sprite();		private var _scalePercent:Number;		private var _scaleCounter:Number;		private var _scaleTime:Number = .9*24;		//private var _shapeFadeDir:String;		private var _pointsDisplay:PointsDisplay;				public var _solveCount:int = 0;		public var _NumOfRounds:int = 5;				private var _gridBackColor:uint = 0x000000;		public var _eyeballCounter:MovieClip = new EyeCounter(this); //y was 7				private var _slideSnd:Sound = new slide_snd();		private var _wrongSnd:Sound = new wrong_snd();		private var _addSnd:Sound = new mouseRoll_snd();		private var _matchMadeSnd:Sound = new matchMade_snd();		private var _inHoleSnd:Sound = new bonus_sting_snd();		private var _outOfHoleSnd:Sound = new increment_points_snd();				public function Board(myDaddy:Object,rows:Number, columns:Number, numOfBlanks:Number, numOfStones:Number, numOfHoles:Number, solution:Array, numOfRounds:int) {			_myDaddy = myDaddy;			_numOfRows = rows;			_numOfColumns = columns;			_numOfBlanks = numOfBlanks;			_numOfStones = numOfStones;			_numOfHoles = numOfHoles;			_solution = solution;			_NumOfRounds = numOfRounds;			if (_numOfHoles > 0){				_isHolePresent = true;			}else{				_isHolePresent = false;			}			//trace ("_numOfBlanks ",_numOfBlanks);			//trace ("_tileArray", _tileArray);			_g = _gSprite.graphics;			_b = _bSprite.graphics;			_startX	= (321 - (_numOfColumns*_tileW))/2; //40			_startY = 99 + (5 - _numOfRows)* _tileH/2; //was 84+						BuildGridBack(_startX,_startY);			this.addChild(_bSprite);			///addChild(_board);						///this.ResetTiles();			///addChild(_solutionsShape);			/*			if (! _myDaddy._LevelMode){				_pointsDisplay = new PointsDisplay();				addChild(_pointsDisplay);			}			*/			this.addEventListener(Event.ADDED_TO_STAGE, OnTheStage, false, 0, true);		}				private function OnTheStage(e:Event):void{			if (_eyeballCounter == null){_eyeballCounter = new EyeCounter(this);}			this.addChildAt(_eyeballCounter,0);			addChild(_board);			this.ResetTiles();			addChild(_solutionsShape);			this.removeEventListener(Event.ADDED_TO_STAGE, OnTheStage);		}						public function ResetTiles():void {			//this first piece never gets executed as the board is killed first			//trace("_tileArray.length",_tileArray.length);			if (_tileArray.length > 0){				//trace("killing some tiles")				var len:uint = _tileArray.length				for(var t:uint = 0; t < len; t++){					_tileArray[t].Kill();					_board.removeChild(_tileArray[t]);					_tileArray[t] = null					if (_tileHoleMapArray[t] == -3){						_board.removeChild(_tileHoleArray[t]);						_tileHoleArray[t] = null					}				}							}						_tileArray = []; //just incase			_tileHoleArray = [];			var counter:int = 0;			//BuildGrid(_startX,_startY);			var daState:Number;			var holes:Number;			for (var ii:int = 0; ii < _numOfRows; ii++){				for (var i:int = 0; i < _numOfColumns; i++){					var daX:Number = _startX + (i * _tileW) + _daSpace * i;					var daY:Number = _startY + (ii * _tileH) + _daSpace * ii;					_tileLocArray.push(new Point(daX, daY));										/////----HOLES-----make all holes blanks-----/////					_tileHoleArray.push(new Tile(this,counter,_tileW,_tileH,daX,daY));					_tileHoleArray[counter].x = daX;					_tileHoleArray[counter].y = daY;					_board.addChild(_tileHoleArray[counter]);					daState = -1;					_tileHoleMapArray.push(daState);					_tileHoleArray[counter].tileState = daState;					///////----END HOLES--------//////										_tileArray.push(new Tile(this,counter,_tileW,_tileH,daX,daY));					_tileArray[counter].x = daX;					_tileArray[counter].y = daY;					_board.addChild(_tileArray[counter]);									daState = GetRandomTileState();					_tileMapArray.push(daState);					_tileArray[counter].tileState = daState;										counter++;				}			}			var ranIndex:int;			/*for (var iii:int = 0; iii < _numOfBlanks; iii++){				ranIndex = Math.floor(Math.random()*((_numOfColumns * _numOfRows) -1) )				_tileMapArray[ranIndex] = -1;				//_tileArray[ranIndex].visible = false;				_tileArray[ranIndex].BlankTile();			}*/			var blankCount:int = _numOfBlanks;			while (blankCount > 0){				ranIndex = Math.floor(Math.random()*((_numOfColumns * _numOfRows) -1) )				if (_tileMapArray[ranIndex] > 0){					_tileMapArray[ranIndex] = -1;					//_tileArray[ranIndex].visible = false;					_tileArray[ranIndex].BlankTile();					blankCount --;				}			}			var stoneCount:int = _numOfStones;			while (stoneCount > 0){				ranIndex = Math.floor(Math.random()*((_numOfColumns * _numOfRows) -1) )				if (_tileMapArray[ranIndex] > 0){					_tileMapArray[ranIndex] = -2;					//_tileArray[ranIndex].visible = false;					_tileArray[ranIndex].StoneTile();					stoneCount --;				}			}									var holeCount:int = _numOfHoles;			while (holeCount > 0){				ranIndex = Math.floor(Math.random()*((_numOfColumns * _numOfRows) -1) )				if (_tileMapArray[ranIndex] > 0){					_tileMapArray[ranIndex] = -1;					_tileArray[ranIndex].BlankTile();					_tileHoleMapArray[ranIndex] = -3;					_tileHoleArray[ranIndex].HoleTile();					_holePositionArray.push(ranIndex)					holeCount --;				}			}									//trace(_tileArray);			//trace(_tileLocArray);			//trace(_tileMapArray);			//trace(_tileHoleMapArray);			//TestForSolution(0);			BuildGrid(_startX,_startY);			_board.addChild(_gSprite);			//trace("reset board in Board. this.numOfChildren = ", this.numChildren)			//trace("_board.numOfChildren = ", _board.numChildren)		}				public function MoveRowOne(tile:Object, deltaX:Number):void {			var myIndex:int = _tileArray.indexOf(tile);			var myRow:int = Math.ceil((myIndex+1)/_numOfColumns);			//trace(myIndex,newX);			var daFirstEmpty:Number = -1;			var testForHole:Boolean = false;						if (deltaX > 0) {   //to the right//				var endOfRow:Number = GetEndOfRow(myIndex);				//trace("endOfRow:", endOfRow)				for (var iii:int = myIndex; iii <= endOfRow; iii++){					if (_tileMapArray[iii] == -2) {						break;					}else if (_tileMapArray[iii] == -1) {						daFirstEmpty = iii;						break;					}				}				if (daFirstEmpty == -1){					if (! TestForSolution(myIndex)){_wrongSnd.play();}				} else if (daFirstEmpty >= 0){					_slideSnd.play();					for( var i:int = daFirstEmpty; i > myIndex; i--){						//_tileArray[i].visible = true;						_tileMapArray[i] = _tileMapArray[i -1];						_tileArray[i].tileState = _tileMapArray[i];						/////_tileArray[i].SetNum(i); //only used for numbered tiles						//_tileArray[i-1].visible = false;						_tileArray[i-1].BlankTile();												//trace("myIndex:", myIndex);						//trace("daFirstEmpty:", daFirstEmpty);						//trace("i:", i);						//trace(_tileMapArray);					}					_tileMapArray[myIndex] = -1;					_myDaddy.AddToMoves();					testForHole = true;				} else {					if (! TestForSolution(myIndex)){_wrongSnd.play();}				}			} else {  /// to the left////				//fist empty def removed				var beginOfRow:Number = GetBeginOfRow(myIndex);				//trace("beginOfRow:", beginOfRow);				for (iii = myIndex; iii >= beginOfRow; iii--){					if (_tileMapArray[iii] == -2) {						break;					}else if (_tileMapArray[iii] == -1) {						daFirstEmpty = iii;						break;					}				}				if (daFirstEmpty >= 0){					_slideSnd.play();					for( i = daFirstEmpty; i < myIndex; i++){						//_tileArray[i].visible = true;						_tileMapArray[i] = _tileMapArray[i + 1];						_tileArray[i].tileState = _tileMapArray[i];						/////_tileArray[i].SetNum(i); //only used for numbered tiles						//_tileArray[i + 1].visible = false;						_tileArray[i + 1].BlankTile();					}					_tileMapArray[myIndex] = -1;					_myDaddy.AddToMoves();					testForHole = true;				} else {					if (! TestForSolution(myIndex)){_wrongSnd.play();}				}			}			if (testForHole){this.TestForHole();}		}				public function MoveColumnOne(tile:Object, deltaY:Number):void {			var myIndex:int = _tileArray.indexOf(tile);			var myColumn:int = (myIndex%_numOfRows) + 1;			//trace("myIndex:", myIndex);			//trace("myColumn",myColumn);			var daFirstEmpty:Number = -1;			var testForHole:Boolean = false;						if (deltaY > 0) {   //down//				var endOfColumn:Number = GetEndOfColumn(myIndex);				//trace("endOfColumn:", endOfColumn)				for (var iii:int = myIndex; iii <= endOfColumn; iii += _numOfColumns){					if (_tileMapArray[iii] == -2) {						break;					}else if (_tileMapArray[iii] == -1) {						daFirstEmpty = iii;						break;					}				}				//trace("daFirstEmpty:", daFirstEmpty)				if (daFirstEmpty == -1){					if (! TestForSolution(myIndex)){_wrongSnd.play();}				} else if (daFirstEmpty >= 0){					_slideSnd.play();					for( var i:int = daFirstEmpty; i > myIndex; i -= _numOfColumns){						//_tileArray[i].visible = true;						_tileMapArray[i] = _tileMapArray[i - _numOfColumns];						_tileArray[i].tileState = _tileMapArray[i];						//_tileArray[i].SetNum(i); //only used for number tiles						//_tileArray[i -_numOfColumns].visible = false;						_tileArray[i -_numOfColumns].BlankTile();						//trace("myIndex:", myIndex);						//trace("daFirstEmpty:", daFirstEmpty);						//trace("i:", i);						//trace(_tileMapArray);					}					_tileMapArray[myIndex] = -1;					_myDaddy.AddToMoves();					testForHole = true;				} else {					if (! TestForSolution(myIndex)){_wrongSnd.play();}				}			} else {  /// up up up////				var beginOfColum:Number = GetBeginOfColumn(myIndex);				//trace("beginOfColum:", beginOfColum);				for (iii = myIndex; iii >= beginOfColum; iii -= _numOfColumns){					if (_tileMapArray[iii] == -2) {						break;					}else if (_tileMapArray[iii] == -1) {						daFirstEmpty = iii;						break;					}				}				if (daFirstEmpty >= 0){					_slideSnd.play();					for( i = daFirstEmpty; i < myIndex; i += _numOfColumns){						//_tileArray[i].visible = true;						_tileMapArray[i] = _tileMapArray[i + _numOfColumns];						_tileArray[i].tileState = _tileMapArray[i];						/////_tileArray[i].SetNum(i); //only used for numbered tiles						//_tileArray[i + _numOfColumns].visible = false;						_tileArray[i + _numOfColumns].BlankTile();						//trace("myIndex:", myIndex);						//trace("daFirstEmpty:", daFirstEmpty);						//trace("i:", i);						//trace(_tileMapArray);					}					_tileMapArray[myIndex] = -1;					_myDaddy.AddToMoves();					testForHole = true;				} else {					if (! TestForSolution(myIndex)){_wrongSnd.play();}				}			}			if (testForHole){this.TestForHole();}		}				private function BuildGridBack(startX,startY):void{			_b.beginFill(_gridBackColor,1);			_b.drawRect(startX,startY,_numOfColumns * _tileW,_numOfRows * _tileH);			//_b.endFill();		}				private function TestForHole():void{			if (!_isHolePresent){return;}			//trace("_holePositionArray",_holePositionArray)			var isHoleIntersect:Boolean = false;			for each (var daHoleIndex in _holePositionArray){				//trace("daHoleIndex",daHoleIndex)				if (_tileMapArray[daHoleIndex] > 0){					isHoleIntersect = true;					break;					}			}			//trace("daHoleIndex",daHoleIndex)			if (isHoleIntersect){				//find new blank					var blankCount:int = 1;					while (blankCount > 0){						var swapBlankIndex:int = Math.round(Math.random()*((_numOfColumns * _numOfRows) -1) )						if (_tileMapArray[swapBlankIndex] == -1){							blankCount --;						}					}				_inHoleSnd.play();				//trace("what is daHoleIndex? --- _tileArray[daHoleIndex].tileState", _tileArray[daHoleIndex].tileState)				//trace("what is daHoleIndex?--- _tileMapArray[daHoleIndex]", _tileMapArray[daHoleIndex])				_tileArray[daHoleIndex].playTile();				var shrinkEye:TweenLite = new TweenLite(_tileArray[daHoleIndex], .6, { 																			    scaleX:0.1,																			   	scaleY:0.1,																				x:_tileArray[daHoleIndex].x+26,																				y:_tileArray[daHoleIndex].y+26,																				alpha:0.0,																				onComplete:FinishEyeInHole,																				onCompleteParams:[daHoleIndex,swapBlankIndex]});				//shrinkEye.play();			}			}				private function FinishEyeInHole(daHoleIndex,swapBlankIndex):void{			if (_tileArray[0] == null){return;}						_outOfHoleSnd.play();			_tileMapArray[swapBlankIndex] = _tileMapArray[daHoleIndex];			_tileArray[swapBlankIndex].tileState = _tileMapArray[swapBlankIndex];			//_tileArray[swapBlankIndex].SetNum(swapBlankIndex);			_tileArray[daHoleIndex].BlankTile();			_tileArray[daHoleIndex].x = _tileLocArray[daHoleIndex].x;			_tileArray[daHoleIndex].y = _tileLocArray[daHoleIndex].y;			_tileArray[daHoleIndex].scaleX = 1.0;			_tileArray[daHoleIndex].scaleY = 1.0;			_tileArray[daHoleIndex].alpha = 1.0;			_tileArray[daHoleIndex].stopTile(); //not needed really. 			_tileMapArray[daHoleIndex] = -1;					}				/////----build grid with graphics for now---////		private function BuildGrid(startX,startY):void{			_g.lineStyle(1, 0xFFFFFF);			_g.moveTo(startX,startY);			_g.lineTo(startX ,startY + (_numOfRows * _tileH));			_g.lineTo(startX + (_numOfColumns * _tileW), startY + (_numOfRows * _tileH));			_g.lineTo(startX + (_numOfColumns * _tileW), startY);			_g.lineTo(startX ,startY);						for(var i:int = 1; i < _numOfRows; i++){				_g.moveTo(startX,startY + (i * _tileH));				_g.lineTo(startX + (_numOfColumns * _tileW),startY + (i * _tileH));			}			for( i = 1; i < _numOfColumns; i++){				_g.moveTo(startX + (i * _tileW), startY );				_g.lineTo(startX + (i * _tileW),startY + (_numOfRows * _tileH));			}					}				public function ShowSolutionShape(startX:Number ,startY:Number,wdth:Number,hgt:Number):void {			/////?/////_matchMadeSnd.play();						//  //if (this.getChildIndex(_solutionsShape)>= 0) {removeChild(_solutionsShape);}			//  //_solutionsShape = new Sprite()			_SShapeStartX = startX;			_SShapeStartY = startY;			_SShapeW = wdth;			_SShapeH = hgt;			//fade out old shape and clear MC			//trace("_solutionsShape.numChildren before if statement:", _solutionsShape.numChildren);			if(_solutionsShape.numChildren >0){				_solutionsShape.removeChildAt(0);				_solutionsShape = null;				var fadeOutTween:TweenLite = new TweenLite(_solutionsShape, .5, {alpha:0.0,onComplete:FinishShowSolutionShape});				////FinishShowSolutionShape();			}else{				FinishShowSolutionShape();			}						//fadeOutTween.play();			////---///								}				private function FinishShowSolutionShape():void{			var child:Shape = new Shape();			var bgColor:uint      = 0xFF0000;         	var borderColor:uint  = 0x000000;			var theIndex:int;			var myRow:int;						_solutionsShape.alpha =  0; //just in case						/*if(_solutionsShape.numChildren >0){				_solutionsShape.removeChildAt(0);				_solutionsShape = null;			}*/			/*			//DIDN'T LOOK GOOD - THINKING ABOUT HOW TO STOP SHAPE FROM LAYERING ON IPHONE			child.graphics.beginFill(0X000000);            child.graphics.lineStyle(0, 0X000000);           	child.graphics.drawRect(0, 0, _SShapeW, _SShapeH);            child.graphics.endFill();			*/			for (var i:int = 0; i < _solution.length; i++){				theIndex = _solution[i]				myRow  = Math.ceil((theIndex+1)/_numOfColumns) -1;				            	child.graphics.beginFill(bgColor);            	child.graphics.lineStyle(5, borderColor);           		child.graphics.drawRect(0 + (_tileW * (theIndex % _numOfColumns ) ), 0 + (_tileH * myRow ), _tileW, _tileH);				//child.graphics.drawRect(startX + (_tileW * (theIndex % _numOfRows ) ), startY + (_tileH * myRow ), _tileW, _tileH);            	child.graphics.endFill();				//addChild(_solutionsShape);			}			_solutionsShape.addChild(child);			//trace("_solutionsShape.numChildren = ", _solutionsShape.numChildren);			var chregx = child.width/2;			var chregy = child.height/2			child.transform.matrix = new Matrix(1, 0, 0, 1, -chregx, -chregy);						//var regx = _solutionsShape.width/2;			//var regy = _solutionsShape.height/2			//_solutionsShape.transform.matrix = new Matrix(1, 0, 0, 1, -regx, -regy);			_solutionsShape.x = _SShapeStartX;			_solutionsShape.y = _SShapeStartY;						if (_solutionsShape.width >= _solutionsShape.height){				//equal of more width				_scalePercent = _SShapeW/_solutionsShape.width;			}else{ //more height				_scalePercent = _SShapeH/_solutionsShape.height;			}			_scalePercent = 1 - _scalePercent;			_scaleCounter = 0;						this.addEventListener(Event.ENTER_FRAME, onShowShapeLoop, false, 0, true);					}				private function onShowShapeLoop (e:Event){				var scaleAmount = 1 - _scalePercent * _scaleCounter/_scaleTime							_solutionsShape.alpha = _scaleCounter/_scaleTime; //+= .08;				_solutionsShape.scaleX = scaleAmount; //-= .05;				_solutionsShape.scaleY = scaleAmount; //-= .05;				_scaleCounter ++;						if (_solutionsShape.alpha >= 1.0){				_solutionsShape.alpha = 1.0;				removeEventListener(Event.ENTER_FRAME, onShowShapeLoop);				//removeChild(_solutionsShape);				//_solutionsShape = new Sprite()			}					}				private function GetEndOfRow(myIndex:Number):Number{			return Math.floor((myIndex + _numOfColumns)/_numOfColumns) * _numOfColumns - 1;		}				private function GetBeginOfRow(myIndex:Number):Number{			return Math.floor(myIndex/_numOfColumns) * _numOfColumns;		}				private function GetEndOfColumn(myIndex:Number):Number{			var myRow:int = Math.ceil((myIndex+ 1)/_numOfColumns);			return myIndex + ((_numOfRows - myRow) * _numOfColumns);		}					private function GetBeginOfColumn(myIndex:Number):Number{			var myRow:int = Math.ceil((myIndex+ 1)/_numOfColumns);			return myIndex - ((myRow - 1) * _numOfColumns);		}				public function TestForSolution(indexnum:Number):Boolean{			//var myIndex:Number = indexnum; // not used at this point			var test:Boolean;			var totalCount:int = _numOfRows * _numOfColumns;			//trace("totalCount",totalCount);			//var shorterCount:int = //pass largest moved index and add numOfColumns +1 and test if it's smaller than totalCount			for (var i:int = 0; i < totalCount -1; i ++){				var firstTileSkin = _tileMapArray[_solution[0] + i]								while(firstTileSkin == -1){ //try to skip -1s in tileArray					if (_solution[0] + i < totalCount -1){						i++						firstTileSkin = _tileMapArray[_solution[0] + i]					}else{						break					}				}				test = true;				_solvedTiles = [_solution[0] + i]; 				//trace("index",i);				//trace("firstTileSkin",firstTileSkin);				//trace("_solution:",_solution);				var testIndex:int; 				//try this to optimize a bit and fix intermittent out of range index bug				if (i + _solution[_solution.length - 1]  >= totalCount ) { // || _tileHoleMapArray[_solution[0] + i] == -3						test = false;						_solvedTiles = [];						break;				}				if ( _tileHoleMapArray[_solution[0] + i] != -3){					for (var ii:int = 1; ii <= (_solution.length - 1); ii++){						//trace("tile_" + String(_solution[ii] + i) + ":", _tileMapArray[_solution[ii] + i]);						testIndex = _solution[ii] + i						if (testIndex >= totalCount) {							test = false;							_solvedTiles = [];							break;						}						//trace(testIndex,_tileHoleMapArray[testIndex]);						if (_tileMapArray[testIndex] != firstTileSkin  || _tileHoleMapArray[testIndex] == -3) 						{							test = false;							_solvedTiles = [];							break;						} else if ((ii <= (_solution.length - 2)) && ( _solution[ii +1] - _solution[ii] == 1) &&  testIndex == GetEndOfRow(testIndex) ) {							//if there is two or more elements to look at in the solution array AND the next one is to the right of this one AND this one is not at the end of the row							test = false;							_solvedTiles = [];							break;						} else {							if (( _solution[1] - _solution[0] == 1) &&  _solution[0] + i == GetEndOfRow( _solution[0] + i)){								//if the second element of the solution is in the same row as the first AND the first we are testing is the last in the row								test = false;								_solvedTiles = [];								break;							}else{								_solvedTiles.push(_solution[ii] + i);							}						}					}				}else{					test = false;					_solvedTiles = [];				}				if (test){					//trace("_tileMapArray",_tileMapArray);					//trace("test1 true",test);					return test;				}			}			//trace("_tileMapArray",_tileMapArray);			//trace("test2 false",test);			return test;		}				//public function GetSolvedTiles(daNum:Number):Array{		//	var solvedTiles:Array = [_solution[0] + daNum];		//	for (var ii:int = 1; ii <= (_solution.length - 1); ii++){;		//		solvedTiles.push(_solution[ii] + daNum);		//	}		//	return solvedTiles;		//}				public function EraseAndRefill(lastTileTouched:Number):void{			DisableTiles();			_eyeballCounter.AddCounter(); //not using the fact that this is a function, returing true when filled.			//_myDaddy.addChild(_myDaddy._interstitial); //just for testing			//_myDaddy._interstitial.playAnim(); //just for testing			this.addEventListener(Event.ENTER_FRAME, onLoopRemoveSolvedTiles, false, 0, true);						var topTile:Number;			for (var i:int = 0; i <= (_solvedTiles.length - 1); i++){				topTile = _board.numChildren -2 - i;				_board.setChildIndex(_tileArray[_solvedTiles[i]],topTile);				//_tileArray[_solvedTiles[i]].Disable(); //taken out as now trying to disable all tiles			}			if (_solvedTiles.indexOf(lastTileTouched) == -1){				//_tileArray[lastTileTouched].Enable(); //taken out as now trying to disable all tiles			}			//var ranindex:int = Math.round(Math.random() * _solvedTiles.length  -1)			for (var ind:int = 0; ind <= (_solvedTiles.length  -1); ind++){				//if (ind == ranindex){   //(Math.random()<.5)					_tileArray[_solvedTiles[ind]].playTile();				//}			}						//_pointsDisplay = new PointsDisplay();			//fix this so that it doesn't leave a memory leak.			//////var pointsDisplay = new PointsDisplay(this,_tileArray[_solvedTiles[1]].x, _tileArray[_solvedTiles[1]].y, _myDaddy.GetNewScore());			//////this.addChild(pointsDisplay);					}				private function onLoopRemoveSolvedTiles(e:Event):void{			if (_tileArray[0] == null){				this.removeEventListener(Event.ENTER_FRAME, onLoopRemoveSolvedTiles);				return;				}			//trace("in onLoopRST,_solvedTiles ",_solvedTiles)						for (var i:int = 0; i <= (_solvedTiles.length  -1); i++){				_tileArray[_solvedTiles[i]].alpha -= .03;				_tileArray[_solvedTiles[i]].scaleX += .05;				_tileArray[_solvedTiles[i]].scaleY += .05;				_tileArray[_solvedTiles[i]].x = _tileLocArray[_solvedTiles[i]].x - Math.floor(((_tileW * _tileArray[_solvedTiles[i]].scaleX) - _tileW)/2.0);				_tileArray[_solvedTiles[i]].y = _tileLocArray[_solvedTiles[i]].y - Math.floor(((_tileH * _tileArray[_solvedTiles[i]].scaleY) - _tileH)/2.0);							}			if (_tileArray[_solvedTiles[0]].alpha <= 0){				//trace("alpha is 0");				//trace(_tileMapArray);				this.removeEventListener(Event.ENTER_FRAME, onLoopRemoveSolvedTiles);				for (var ii:int = 0; ii <= (_solvedTiles.length - 1); ii++){					//_tileArray[_solvedTiles[ii]].visible = false					_tileArray[_solvedTiles[ii]].BlankTile();					_tileArray[_solvedTiles[ii]].alpha = 1;					_tileArray[_solvedTiles[ii]].scaleX = 1.0;					_tileArray[_solvedTiles[ii]].scaleY = 1.0;					_tileArray[_solvedTiles[ii]].x = _tileLocArray[_solvedTiles[ii]].x;					_tileArray[_solvedTiles[ii]].y = _tileLocArray[_solvedTiles[ii]].y;					//_tileArray[_solvedTiles[ii]].Enable(); //trying to enable all tiles at the end					_tileMapArray[_solvedTiles[ii]] = -1;				}								//trace(_tileMapArray);								//_myDaddy.AddToScore();								///move add replacements back here				var numOfReplacements:Number = _solvedTiles.length				var minusOneList:Array = []				for (var iii:int = 0; iii <= (_tileMapArray.length - 1); iii++){					if (_tileMapArray[iii] == -1 && _tileHoleMapArray[iii] != -3){						minusOneList.push(iii);					}				}				//trace("minusOneList",minusOneList);								var holdAnIndex:Number;				var daState:Number;				while (numOfReplacements > 0){					holdAnIndex = minusOneList[Math.floor(Math.random() * (minusOneList.length -1))]					daState = GetRandomTileState();					//trace("holdAnIndex", holdAnIndex);					//trace("daState", daState);					_addSnd.play();					_tileArray[holdAnIndex].tileState = daState;					//_tileArray[holdAnIndex].visible = true;					_tileMapArray[holdAnIndex] = daState;					minusOneList.splice(minusOneList.indexOf(holdAnIndex),1);					//trace("_tileMapArray", _tileMapArray);					//trace("minusOneList", minusOneList);					numOfReplacements --;				}				DoneRemovingSolvedTiles()			}					}				private function DoneRemovingSolvedTiles():void{			_solveCount += 1			_myDaddy.AddToScore();			if (_solveCount >= _NumOfRounds){				_solveCount = 0;				_myDaddy.ChangeChallenge();			}else{				EnableTiles();			}					}				private function GetRandomTileState():Number{			return Math.ceil(Math.random()*4);					}				public function EnableTiles():void{			//trace("tiles were enabled in Board/EnableTiles()");			for each (var tile in _tileArray){				tile.Enable();			}		}				public function DisableTiles():void{			//trace("tiles were disabled in Board/DisableTiles()");			for each (var tile in _tileArray){				tile.Disable();			}		}				public function ResetEyeCounter(numOfRounds:Number):void{			_eyeballCounter.ResetCounter(numOfRounds);			this.addChildAt(_eyeballCounter,0);		}				public function ClearBoard():void{			//trace("clearing board");			if (_tileArray.length > 0){				//trace("Killing Board");				var arraysize:int = _tileArray.length;				for (var i:int = 0; i < arraysize; i++){					_tileArray[i].Kill();					_board.removeChild(_tileArray[i]);					_tileArray[i] = null;					if (_tileHoleMapArray[i] == -3){						_board.removeChild(_tileHoleArray[i]);						_tileHoleArray[i] = null					}				}			}					}				public function PauseScreen():void{							}		public function ResumeScreen():void{							}			public function Kill():void{			if (_tileArray.length > 0){				//trace("Killing Board");				var arraysize:int = _tileArray.length;				for (var i:int = 0; i < arraysize; i++){					_tileArray[i].Kill();					_board.removeChild(_tileArray[i]);					_tileArray[i] = null;					if (_tileHoleMapArray[i] == -3){						_board.removeChild(_tileHoleArray[i]);						_tileHoleArray[i] = null					}				}			}			removeChild(_solutionsShape);			_solutionsShape = null;			removeChild(_eyeballCounter);			_eyeballCounter = null;			this.removeChild(_bSprite);			_bSprite = null;		}		}}/*//////------a different game-----/////		public function MoveRow(tile:Object, deltaX:Number):void {			var myIndex:int = _tileArray.indexOf(tile);			var myRow:int = Math.ceil(myIndex/_numOfColumns);			//trace(myIndex,newX)			for (var i:int = 0; i < _numOfColumns; i++) {				var daIndex:int = (myRow -1) * _numOfColumns + i;				_tileArray[daIndex].x += deltaX;			}		}				public function MoveColumn(tile:Object, deltaY:Number):void {			var myIndex:int = _tileArray.indexOf(tile);			var myColumn:int = Math.ceil(myIndex/_numOfRows);			//trace(myIndex,newX)			for (var i:int = 0; i < _numOfColumns; i++) {				var daIndex:int = (myColumn -1)  + (_numOfRows * i);				_tileArray[daIndex].y += deltaY;			}		}		*/